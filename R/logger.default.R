#' @title Initialize a log object.
#'
#' @description Logging is a central aspect of each EA. Besides the final solution(s)
#' especially in research often we need to keep track of different aspects of the
#' evolutionary process, e.g., fitness statistics. The logger of \pkg{ecr} keeps
#' track of different user-defined statistics and the population.
#' It is also used for monitoring by the default console-monitor (see {makeECRConsoleMonitor})
#' and passed down to stopping conditions (see \code{makeECRTerminator}). Most
#' important this logger is used internally by the \code{ecr} black-box function.
#'
#' @note If rapid prototyping of EAs is the goal and \code{ecr} is not sufficient
#' one is of cource not required to use this logger.
#'
#' @template arg_control
#' @param log.stats [\code{list}]\cr
#'   List of functions for statistics computation on the fitness values of each
#'   generation. Each entry should be the R function as a character string or a
#'   list with elements \code{fun} for the function, and \code{pars} for additional
#'   parameters which shall be passed to the corresponding function.
#'   Each function is required to return a scalar numeric value.
#'   By default the minimum, mean and maximum of the fitness values is computed.
#' @param log.pop [\code{logical(1)}]\cr
#'   Shall the entire population be saved?
#'   Default is \code{FALSE}.
#' @param init.size [\code{integer(1)}]\cr
#'   Initial number of rows of the stats slot of the logger, where the fitness
#'   statistics are stored. The size of the statistics log doubled each time an
#'   overflow occurs.
#'   Default is 1000.
#' @return [\code{ecr2_logger}]
#'   An S3 object of class \code{ecr2_logger} with the following components:
#'   \describe{
#'     \item{log.stats}{The \code{log.stats} list.}
#'     \item{log.pop}{The \code{log.pop} parameter.}
#'     \item{init.size}{Initial size of the log.}
#'     \item{env}{The actual log. This is an R environment which ensures, that
#'     in-place modification is possible.}
#'   }
#' @family logging
#' @export
initLogger = function(
  control,
  log.stats = list("min", "mean", "max"),
  log.pop = FALSE, init.size = 1000L) {

  assertClass(control, "ecr2_control")
  assertList(log.stats)
  assertFlag(log.pop)
  init.size = asInt(init.size, lower = 10L)

  stats = ensureNamedStats(log.stats)

  env = new.env()
  env$stats = BBmisc::makeDataFrame(ncol = length(stats) + 1L, nrow = init.size,
    col.types = "numeric", col.names = c("gen", names(stats)))
  env$cur.line = 1L
  env$time.started = Sys.time()
  env$n.evals = 0L
  env$n.gens = 0L
  env$task = control$task
  env$log.pop = log.pop

  if (log.pop) {
    env$pop = vector("list", length = init.size)
  }

  makeS3Obj("ecr2_logger",
    log.stats = stats,
    log.pop = log.pop,
    init.size = init.size,
    env = env
  )
}

#' @title Update the log.
#'
#' @description This function modifies the log in-place, i.e., without making
#' copies.
#'
#' @param log [\code{ecr2_logger}]\cr
#'   The log generated by \code{initLogger}.
#' @param population [\code{list}]\cr
#'   List of individuals.
#' @param fitness [\code{matrix}]\cr
#'   Matrix of fitness values (each column contains the fitness value(s) for
#'   one individual) of \code{population}.
#' @param n.evals [\code{integer(1)}]\cr
#'   Number of fitness function evaluations performed in the last generation.
#' @param ... [any]\cr
#'   Furhter arguments. Not used at the moment.
#' @family logging
#' @export
updateLogger = function(log, population, fitness, n.evals, ...) {
  # basic stuff
  log$env$time.passed = Sys.time() - log$env$time.started
  log$env$n.gens = log$env$n.gens + 1L
  log$env$n.evals = log$env$n.evals + n.evals

  # keep track of best individual
  n.objectives = nrow(fitness)
  if (n.objectives == 1L) {
    if (is.null(log$env$best.y)) {
      log$env$best.x = NA
      log$env$best.y = if (log$env$task$minimize) Inf else -Inf
    }
    if (log$env$task$minimize) {
      cur.best.idx = which.min(as.numeric(fitness))
      cur.best.y = fitness[, cur.best.idx]
      if (log$env$best.y > cur.best.y) {
        log$env$best.y = cur.best.y
        log$env$best.x = population[cur.best.idx]
      }
    } else {
      cur.best.idx = which.max(as.numeric(fitness))
      cur.best.y = fitness[, cur.best.idx]
      if (log$env$best.y < cur.best.y) {
        log$env$best.y = cur.best.y
        log$env$best.x = population[cur.best.idx]
      }
    }
  }

  # eventually make log bigger (exponential growing)
  #FIXME: make growing fun a parameter
  n.log = nrow(log$env$stats)

  # grow memory
  if (n.log < log$env$cur.line) {
    catf("increasing log size! Doubling size: %i -> %i", n.log, 2 * n.log)
    log$env$stats = rbind(log$env$stats, makeDataFrame(ncol = ncol(log$env$stats),
      nrow = n.log * 2, col.types = "numeric", col.names = names(log$env$stats)))

    if (log$env$log.pop) {
      log$env$pop = c(log$env$pop, vector("list", length = n.log * 2))
    }
  }

  #catf("log size: %i, Gen: %i", nrow(log$env$stats), log$env$n.gens)
  # compute stats for current population
  cur.stats = lapply(log$log.stats, function(stat.fun) {
    if (is.list(stat.fun))
      return(do.call(stat.fun$fun, c(list(fitness), stat.fun$pars)))
    return(stat.fun(fitness))
  })

  log$env$stats[log$env$cur.line, ] = c(list(gen = log$env$n.gens), cur.stats)

  # store population if requested
  if (log$env$log.pop) {
    log$env$pop[[log$env$cur.line]] = list(population = population, fitness = fitness)
  }
  log$env$cur.line = log$env$cur.line + 1L
}

# Helper function to ensure proper naming of the log.stats list passed
# to the logger.
ensureNamedStats = function(stats) {
  no.names = names(stats) == ""
  if (length(no.names) == 0L)
    no.names = rep(TRUE, length(stats))
  # which funs are no characters?
  no.char = !sapply(stats, is.character)
  # if both is true, i.e. unnamed and no char, we cannot determine a name
  if (all(no.char & no.names))
    stopf("log.stats needs to be a list of function names as strings or named lists.")
  # otherwise take chars as names ...
  names(stats)[no.names] = stats[no.names]
  # ... and convert names to functions
  stats[no.names] = sapply(stats[no.names], get)
  return(stats)
}

#' @title Access to logged stats.
#'
#' @description Simple getter for the logged fitness statistics.
#'
#' @param log [\code{ecr2_logger}]\cr
#'   The log generated by \code{initLogger}.
#' @param trim [\code{logical(1)}]\cr
#'   Should unused lines in the logged be cut off?
#'   Usually one wants this behaviour.
#'   Thus the default is \code{TRUE}.
#' @return [\code{data.frame}] Logged statistics.
#' @family logging
#' @export
getLoggedStats = function(log, trim = TRUE) {
  assertClass(log, "ecr2_logger")
  assertFlag(trim)
  stats = log$env$stats
  if (trim & (log$env$cur.line < nrow(stats))) {
    stats = stats[seq.int(log$env$cur.line - 1L), , drop = FALSE]
  }
  return(stats)
}

#' @title Access to logged populations.
#'
#' @description Simple getter for the logged populations.
#'
#' @details This functions throws an error if the logger was initialized with
#' \code{log.pop = FALSE} (see \code{initLogger}).
#'
#' @param log [\code{ecr2_logger}]\cr
#'   The log generated by \code{initLogger}.
#' @param trim [\code{logical(1)}]\cr
#'   Should unused lines in the logged be cut off?
#'   Usually one wants this behaviour.
#'   Thus the default is \code{TRUE}.
#' @return [\code{list}] List of populations.
#' @family logging
#' @export
getLoggedPopulations = function(log, trim = TRUE) {
  assertClass(log, "ecr2_logger")
  assertFlag(trim)
  if (!log$log.pop)
    stopf("Log did not store populations.")

  pops = log$env$pop
  if (is.null(pops))
    stopf("This should not happen. Populations should be saved, but not found.")

  if (trim & (log$env$cur.line < length(pops))) {
    pops = pops[seq.int(log$env$cur.line - 1L)]
  }
  return(pops)
}
